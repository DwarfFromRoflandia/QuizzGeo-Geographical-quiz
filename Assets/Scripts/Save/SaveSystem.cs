using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.IO;//это пространство имён мы используем всякий раз, когда мы хотим работать с файлами в нашей операционной системе
using System.Runtime.Serialization.Formatters.Binary;//это пространство имён позволит нам получить доступ к двоичному форматеру

public static class SaveSystem //статические класс это тот класс у которого нельзя создать экземпляр данного класса. Мы не хотим делать несколько версий нашей системы сохранения и поэтому делаем класс статическим
{
    public static void SaveData(SaveAndLoadData _saveAndLoadData)//создаём статическую функцию для того, чтобы вызывать её без создания экземпляра класса. А также в параметры класса передаём экземпляр класса SaveAndLoadData для того, чтобы скрипт знал, какие данные нужно сохранять
    {
        BinaryFormatter formatter = new BinaryFormatter(); //данной строчкой создаём экземпляр класса, который отвечает за создание двоичного формата. Класс BinaryFormatter поможет перевести значения переменных в двоичные значения. Т.е. он отвечает за процесс сериализации данных. 

        //ниже создаём путь для сохранения файла. Вместо того, чтобы писать путь напрямую, воспользуемся встроенной функцией Application.persistentDataPath. Она представляет собой путь к каталогу, в котором можно хранить данные, которые хотим сохранить между запусками игры. PersistDataPath указывает на общедоступный каталог на устройстве. 
        //string path = Application.persistentDataPath + "/saveAndLoadData.sun";//так как мы по сути здесь создаём свой собственный файл, который является просто двоичным файлом, мы можем использовать любой выдуманный тип файла, который захотим использовать
        string path = Application.persistentDataPath + "/saveData.moon";
        //строчкой ниже мы создаём новый файл, а именно файловый поток. Файловый поток - это поток данных содержащихся в файле и мы можем использовать определённый файловый поток для чтения и записи из файла
        FileStream stream = new FileStream(path, FileMode.Create);//в параметрах мы казываем путь, а вторым параметром определяем режим файла. Режим Create создаст новый файл, а если он уже существует, то этот режим переопределит его
        
        Data data = new Data(_saveAndLoadData);//создаём экземпляр класса Data и в конструктор данного класса мы передаём экземпляр класса SaveAndLoadData

        formatter.Serialize(stream, data);//реализуем форматирование сериализации, т.е. записываем данные в файл. В скобках к этому методу стоит указать переменную файлового потока, а также переменную, которая позволит нужным данным перенестись в файл
        stream.Close();//закрываем файловый поток после сохранения данных

    }

    public static Data LoadData()//в методе загрузки мы не будем использовать void, т.к. мы собираемся загружать данные обратно в игру и для этого нам потребуется вернуть их с помощью оператора return
    {
        //string path = Application.persistentDataPath + "/saveAndLoadData.sun";
        string path = Application.persistentDataPath + "/saveData.moon";

        if (File.Exists(path))//делаем проверку на то, существует ли файл по данному пути
        {
            BinaryFormatter formatter = new BinaryFormatter();//для десериализации файлового потока снова создаём экземпляр класса BinaryFormatter
            FileStream stream = new FileStream(path, FileMode.Open);//создаём новый поток файлов и определяем его режим, как режим открытого файлового потока

            Data data = formatter.Deserialize(stream) as Data; //в переменную экземплра класса Data присваиваем десериализацию файлового потока, а с помощью опреатора as мы просто говорим с каким типом данных мы работаем
            stream.Close();//закрываем файловый поток

            return data;//возвращаем десериализованные данные из файла обратно в игру
        }
        else
        {
            Debug.LogError("Save file not found in" + path);
            return null;
        }
    }
}
