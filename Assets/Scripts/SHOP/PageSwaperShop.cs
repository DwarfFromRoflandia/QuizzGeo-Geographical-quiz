using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.EventSystems;

public class PageSwaperShop : MonoBehaviour, IDragHandler, IEndDragHandler //эти два класса позволяют использовать методы, которые нужны для определение того, когда перетаскивание панели(свайп) начинается и когда оно заканчивается
{
    private Vector3 panelLocation;//переменная, которая будет использоваться для сохранение текущего состояния ожидания(состояние Idle) нашей панели
    public float precentThreshold = 0.2f;//эта переменная нужна для того, чтобы определить насколько далеко и сильно нам нужно свайпнуть по экрану, чтобы это считалось свайпом
    public float easing = 0.5f;//мы будем использовать эту переменную для того, чтобы определить, как долго в секундах панель будет перемещаться в нужное место

    public int totalPages = 1;//переменная, отвечающая за то, сколько всего панелей с уровнями у нас будет.
    private int currentPage = 1;//переменная, которая обзначает текущую панель, на которой находится игрок

    public int CurrentPage { get => currentPage; }

    [SerializeField] private Animator animationHintFiftyFifty;
    [SerializeField] private Animator _hearts;

    public GameObject[] _Pointers;

    private void Start()
    {
        panelLocation = transform.position;//определяем позицию путём присваиваения в переменную, которая отвечает за местоположение панели с уровнями, текущее значение позиции  
    }


    //этот встроенный метод, который определяет свайпы привязан к классу IDragHandler
    public void OnDrag(PointerEventData data) //здесь переменная data содержит важную информацию о нашем перетаскивании
    {
        float difference = data.pressPosition.x - data.position.x; //выщитываем разницу между значениями текущей позиции перетаскивания и местом начала перетаскивания

        transform.position = panelLocation - new Vector3(difference, 0, 0); //этим способом мы вычитаем местоположение панели в режиме ожидания(состояние Idle) из расстояния, которое мы перетаскиваем
    }

    //этот встроенный метод, который определяет свайпы привязан к классу IEndDragHandler
    public void OnEndDrag(PointerEventData data)
    {
        //строчкой ниже мы рассчитываем процент, который мы провели по отношению к ширине экрана(т.е. мы берём разницу между значениями текущей позиции перетаскивания и местом начала перетаскивания и делим её на ширину экрана)
        float percentage = (data.pressPosition.x - data.position.x) / Screen.width;//теперь, если мы проведём пальцем справа налево, то значение будет положительным, а если проведём пальцем слева направо, то значение будет отрицательным

        //Этим условием проверяем, если пройденный процент больше или равен минимальному проценту, то мы хотим перейти нас следующую страницу(панель). В условии мы используем математические формулы, чтобы получить абсолютное значение, поэтому нам не нужно писать несколько операторов if 
        if (Mathf.Abs(percentage) >= precentThreshold)//если наше процентное значение отрицательное, то мы хотим настроить новое местоположение для перемещения нашей панели
        {
            Vector3 newLocation = panelLocation;//определяем новое векторное местоположение и устанавливаем его равным нашему состоянию ожидания, которое определяется, как местоположение панели
            if (percentage > 0 && currentPage < totalPages)//этот оператор определяет, что если мы провели пальцем влевом направлении, то загружается вторая страница, а эта проверка проверке currentPage < totalPages нам гарантирует, что мы не загрузим больше никаких страниц, если мы находимся на последней странице странице
            {
                newLocation += new Vector3(-Screen.width, 0, 0);//если условие выполняется, то мы устанавливаем для нашего нового местоположения значение + и равное новому вектору 3 и поставитм отрицательную ширину точки экрана для значения x, а также обнулим все значения 
                currentPage++;//благодаря этому инкременту мы будем отслеживать на какой странице мы находимся
            }
            else if (percentage < 0 && currentPage > 1)//этот оператор определяет, что если мы провели пальцем вправом направлении, то загружается предыдущая страница, а это проверка currentPage > 1 не позволит больше нам загружать никаких страниц, если мы находимся на первой странице
            {
                newLocation += new Vector3(Screen.width, 0, 0);
                currentPage--;//благодаря этому декременту мы будем отслеживать на какой странице мы находимся
            }

            StartCoroutine(SmoothMove(transform.position, newLocation, easing));//эта строчка запускает корутину и она отвечает за плавность перемещения панели в нужное нам место. Здесь для второго параметра передаём значение нвой позиции
            panelLocation = newLocation;//обновляем состояние ожидания(состояние Idle) до этого нового местоположения. 

            for (int i = 0; i < _Pointers.Length; i++)
            {
                if (currentPage == 1)
                {
                    _Pointers[3].SetActive(true);
                    _Pointers[4].SetActive(false);
                    _Pointers[5].SetActive(false);
                }
                else if (currentPage == 2)
                {
                    _Pointers[3].SetActive(false);
                    _Pointers[4].SetActive(true);
                    _Pointers[5].SetActive(false);
                }
                else if (currentPage == 3)
                {
                    _Pointers[3].SetActive(false);
                    _Pointers[4].SetActive(false);
                    _Pointers[5].SetActive(true);
                }
            }
        }
        else//это условие нужно для того, чтобы наша панель с уровнями вернулась в исходное положение, если мы не проведём пальцем выше нашего порого касания 
        {
            StartCoroutine(SmoothMove(transform.position, panelLocation, easing));//эта строчка запускает корутину и она отвечает за плавность перемещения панели в нужное нам место. Здесь для второго параметра передаём значение местоположение панели, чьё значение явялется состоянием ожидания(состояние Idle)
        }

    }



    //этот метод нам нужен для того, чтобы у нас был плавный и мягкий переход между панелями. Этот метод приводит перемещение позиции панели из изначальной позиции в n-позицию за определённое количество секунд, которое мы определяем в этом методе
    IEnumerator SmoothMove(Vector3 startpos, Vector3 endpos, float seconds)//передаём в метод три параметра
    {
        float t = 0f;
        while (t <= 1.0f)
        {
            t += Time.deltaTime / seconds;
            transform.position = Vector3.Lerp(startpos, endpos, Mathf.SmoothStep(0f, 1f, t));
            //здесь мы используем корутину, которая представляет из себя функцию, которую можно запускать в нескольких фреймах(кадрах) игры. Это важно сделать, потому что мы хотим анимировать переход страницы из точку A в точку B
            yield return null;//т.е. этой строчкой мы говорим, что мы хотим, чтобы наш метод дождался следующего кадра(фрейма), прежде чем продожить
        }
    }
}
